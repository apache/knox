{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) {\n    if (b.hasOwnProperty(p)) d[p] = b[p];\n  }\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar isFunction_1 = require('../util/isFunction');\n\nvar Observable_1 = require('../Observable');\n\nvar Subscription_1 = require('../Subscription');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar FromEventPatternObservable = function (_super) {\n  __extends(FromEventPatternObservable, _super);\n\n  function FromEventPatternObservable(addHandler, removeHandler, selector) {\n    _super.call(this);\n\n    this.addHandler = addHandler;\n    this.removeHandler = removeHandler;\n    this.selector = selector;\n  }\n  /**\n   * Creates an Observable from an API based on addHandler/removeHandler\n   * functions.\n   *\n   * <span class=\"informal\">Converts any addHandler/removeHandler API to an\n   * Observable.</span>\n   *\n   * <img src=\"./img/fromEventPattern.png\" width=\"100%\">\n   *\n   * Creates an Observable by using the `addHandler` and `removeHandler`\n   * functions to add and remove the handlers, with an optional selector\n   * function to project the event arguments to a result. The `addHandler` is\n   * called when the output Observable is subscribed, and `removeHandler` is\n   * called when the Subscription is unsubscribed.\n   *\n   * @example <caption>Emits clicks happening on the DOM document</caption>\n   * function addClickHandler(handler) {\n   *   document.addEventListener('click', handler);\n   * }\n   *\n   * function removeClickHandler(handler) {\n   *   document.removeEventListener('click', handler);\n   * }\n   *\n   * var clicks = Rx.Observable.fromEventPattern(\n   *   addClickHandler,\n   *   removeClickHandler\n   * );\n   * clicks.subscribe(x => console.log(x));\n   *\n   * @see {@link from}\n   * @see {@link fromEvent}\n   *\n   * @param {function(handler: Function): any} addHandler A function that takes\n   * a `handler` function as argument and attaches it somehow to the actual\n   * source of events.\n   * @param {function(handler: Function, signal?: any): void} [removeHandler] An optional function that\n   * takes a `handler` function as argument and removes it in case it was\n   * previously attached using `addHandler`. if addHandler returns signal to teardown when remove,\n   * removeHandler function will forward it.\n   * @param {function(...args: any): T} [selector] An optional function to\n   * post-process results. It takes the arguments from the event handler and\n   * should return a single value.\n   * @return {Observable<T>}\n   * @static true\n   * @name fromEventPattern\n   * @owner Observable\n   */\n\n\n  FromEventPatternObservable.create = function (addHandler, removeHandler, selector) {\n    return new FromEventPatternObservable(addHandler, removeHandler, selector);\n  };\n  /** @deprecated internal use only */\n\n\n  FromEventPatternObservable.prototype._subscribe = function (subscriber) {\n    var _this = this;\n\n    var removeHandler = this.removeHandler;\n    var handler = !!this.selector ? function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n      }\n\n      _this._callSelector(subscriber, args);\n    } : function (e) {\n      subscriber.next(e);\n    };\n\n    var retValue = this._callAddHandler(handler, subscriber);\n\n    if (!isFunction_1.isFunction(removeHandler)) {\n      return;\n    }\n\n    subscriber.add(new Subscription_1.Subscription(function () {\n      //TODO: determine whether or not to forward to error handler\n      removeHandler(handler, retValue);\n    }));\n  };\n\n  FromEventPatternObservable.prototype._callSelector = function (subscriber, args) {\n    try {\n      var result = this.selector.apply(this, args);\n      subscriber.next(result);\n    } catch (e) {\n      subscriber.error(e);\n    }\n  };\n\n  FromEventPatternObservable.prototype._callAddHandler = function (handler, errorSubscriber) {\n    try {\n      return this.addHandler(handler) || null;\n    } catch (e) {\n      errorSubscriber.error(e);\n    }\n  };\n\n  return FromEventPatternObservable;\n}(Observable_1.Observable);\n\nexports.FromEventPatternObservable = FromEventPatternObservable; //# sourceMappingURL=FromEventPatternObservable.js.map","map":null,"metadata":{},"sourceType":"script"}
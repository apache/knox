{"ast":null,"code":"import _assertThisInitialized from \"/Users/mbalazs/projects/knox/knox-homepage-ui/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/Users/mbalazs/projects/knox/knox-homepage-ui/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/mbalazs/projects/knox/knox-homepage-ui/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/mbalazs/projects/knox/knox-homepage-ui/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/mbalazs/projects/knox/knox-homepage-ui/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"/Users/mbalazs/projects/knox/knox-homepage-ui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/mbalazs/projects/knox/knox-homepage-ui/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isScheduler } from '../util/isScheduler';\nexport function bufferTime(bufferTimeSpan) {\n  var length = arguments.length;\n  var scheduler = async;\n\n  if (isScheduler(arguments[arguments.length - 1])) {\n    scheduler = arguments[arguments.length - 1];\n    length--;\n  }\n\n  var bufferCreationInterval = null;\n\n  if (length >= 2) {\n    bufferCreationInterval = arguments[1];\n  }\n\n  var maxBufferSize = Number.POSITIVE_INFINITY;\n\n  if (length >= 3) {\n    maxBufferSize = arguments[2];\n  }\n\n  return function bufferTimeOperatorFunction(source) {\n    return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n  };\n}\n\nvar BufferTimeOperator = /*#__PURE__*/function () {\n  function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    _classCallCheck(this, BufferTimeOperator);\n\n    this.bufferTimeSpan = bufferTimeSpan;\n    this.bufferCreationInterval = bufferCreationInterval;\n    this.maxBufferSize = maxBufferSize;\n    this.scheduler = scheduler;\n  }\n\n  _createClass(BufferTimeOperator, [{\n    key: \"call\",\n    value: function call(subscriber, source) {\n      return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n    }\n  }]);\n\n  return BufferTimeOperator;\n}();\n\nvar Context = /*#__PURE__*/_createClass(function Context() {\n  _classCallCheck(this, Context);\n\n  this.buffer = [];\n});\n\nvar BufferTimeSubscriber = /*#__PURE__*/function (_Subscriber) {\n  _inherits(BufferTimeSubscriber, _Subscriber);\n\n  var _super = _createSuper(BufferTimeSubscriber);\n\n  function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    var _this;\n\n    _classCallCheck(this, BufferTimeSubscriber);\n\n    _this = _super.call(this, destination);\n    _this.bufferTimeSpan = bufferTimeSpan;\n    _this.bufferCreationInterval = bufferCreationInterval;\n    _this.maxBufferSize = maxBufferSize;\n    _this.scheduler = scheduler;\n    _this.contexts = [];\n\n    var context = _this.openContext();\n\n    _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n\n    if (_this.timespanOnly) {\n      var timeSpanOnlyState = {\n        subscriber: _assertThisInitialized(_this),\n        context: context,\n        bufferTimeSpan: bufferTimeSpan\n      };\n\n      _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    } else {\n      var closeState = {\n        subscriber: _assertThisInitialized(_this),\n        context: context\n      };\n      var creationState = {\n        bufferTimeSpan: bufferTimeSpan,\n        bufferCreationInterval: bufferCreationInterval,\n        subscriber: _assertThisInitialized(_this),\n        scheduler: scheduler\n      };\n\n      _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n\n      _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n    }\n\n    return _this;\n  }\n\n  _createClass(BufferTimeSubscriber, [{\n    key: \"_next\",\n    value: function _next(value) {\n      var contexts = this.contexts;\n      var len = contexts.length;\n      var filledBufferContext;\n\n      for (var i = 0; i < len; i++) {\n        var context = contexts[i];\n        var buffer = context.buffer;\n        buffer.push(value);\n\n        if (buffer.length == this.maxBufferSize) {\n          filledBufferContext = context;\n        }\n      }\n\n      if (filledBufferContext) {\n        this.onBufferFull(filledBufferContext);\n      }\n    }\n  }, {\n    key: \"_error\",\n    value: function _error(err) {\n      this.contexts.length = 0;\n\n      _get(_getPrototypeOf(BufferTimeSubscriber.prototype), \"_error\", this).call(this, err);\n    }\n  }, {\n    key: \"_complete\",\n    value: function _complete() {\n      var contexts = this.contexts,\n          destination = this.destination;\n\n      while (contexts.length > 0) {\n        var context = contexts.shift();\n        destination.next(context.buffer);\n      }\n\n      _get(_getPrototypeOf(BufferTimeSubscriber.prototype), \"_complete\", this).call(this);\n    }\n  }, {\n    key: \"_unsubscribe\",\n    value: function _unsubscribe() {\n      this.contexts = null;\n    }\n  }, {\n    key: \"onBufferFull\",\n    value: function onBufferFull(context) {\n      this.closeContext(context);\n      var closeAction = context.closeAction;\n      closeAction.unsubscribe();\n      this.remove(closeAction);\n\n      if (!this.closed && this.timespanOnly) {\n        context = this.openContext();\n        var bufferTimeSpan = this.bufferTimeSpan;\n        var timeSpanOnlyState = {\n          subscriber: this,\n          context: context,\n          bufferTimeSpan: bufferTimeSpan\n        };\n        this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n      }\n    }\n  }, {\n    key: \"openContext\",\n    value: function openContext() {\n      var context = new Context();\n      this.contexts.push(context);\n      return context;\n    }\n  }, {\n    key: \"closeContext\",\n    value: function closeContext(context) {\n      this.destination.next(context.buffer);\n      var contexts = this.contexts;\n      var spliceIndex = contexts ? contexts.indexOf(context) : -1;\n\n      if (spliceIndex >= 0) {\n        contexts.splice(contexts.indexOf(context), 1);\n      }\n    }\n  }]);\n\n  return BufferTimeSubscriber;\n}(Subscriber);\n\nfunction dispatchBufferTimeSpanOnly(state) {\n  var subscriber = state.subscriber;\n  var prevContext = state.context;\n\n  if (prevContext) {\n    subscriber.closeContext(prevContext);\n  }\n\n  if (!subscriber.closed) {\n    state.context = subscriber.openContext();\n    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n  }\n}\n\nfunction dispatchBufferCreation(state) {\n  var bufferCreationInterval = state.bufferCreationInterval,\n      bufferTimeSpan = state.bufferTimeSpan,\n      subscriber = state.subscriber,\n      scheduler = state.scheduler;\n  var context = subscriber.openContext();\n  var action = this;\n\n  if (!subscriber.closed) {\n    subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, {\n      subscriber: subscriber,\n      context: context\n    }));\n    action.schedule(state, bufferCreationInterval);\n  }\n}\n\nfunction dispatchBufferClose(arg) {\n  var subscriber = arg.subscriber,\n      context = arg.context;\n  subscriber.closeContext(context);\n}","map":{"version":3,"sources":["/Users/mbalazs/projects/knox/knox-homepage-ui/node_modules/rxjs/_esm2015/internal/operators/bufferTime.js"],"names":["async","Subscriber","isScheduler","bufferTime","bufferTimeSpan","length","arguments","scheduler","bufferCreationInterval","maxBufferSize","Number","POSITIVE_INFINITY","bufferTimeOperatorFunction","source","lift","BufferTimeOperator","subscriber","subscribe","BufferTimeSubscriber","Context","buffer","destination","contexts","context","openContext","timespanOnly","timeSpanOnlyState","add","closeAction","schedule","dispatchBufferTimeSpanOnly","closeState","creationState","dispatchBufferClose","dispatchBufferCreation","value","len","filledBufferContext","i","push","onBufferFull","err","shift","next","closeContext","unsubscribe","remove","closed","spliceIndex","indexOf","splice","state","prevContext","action","arg"],"mappings":";;;;;;;AAAA,SAASA,KAAT,QAAsB,oBAAtB;AACA,SAASC,UAAT,QAA2B,eAA3B;AACA,SAASC,WAAT,QAA4B,qBAA5B;AACA,OAAO,SAASC,UAAT,CAAoBC,cAApB,EAAoC;AACvC,MAAIC,MAAM,GAAGC,SAAS,CAACD,MAAvB;AACA,MAAIE,SAAS,GAAGP,KAAhB;;AACA,MAAIE,WAAW,CAACI,SAAS,CAACA,SAAS,CAACD,MAAV,GAAmB,CAApB,CAAV,CAAf,EAAkD;AAC9CE,IAAAA,SAAS,GAAGD,SAAS,CAACA,SAAS,CAACD,MAAV,GAAmB,CAApB,CAArB;AACAA,IAAAA,MAAM;AACT;;AACD,MAAIG,sBAAsB,GAAG,IAA7B;;AACA,MAAIH,MAAM,IAAI,CAAd,EAAiB;AACbG,IAAAA,sBAAsB,GAAGF,SAAS,CAAC,CAAD,CAAlC;AACH;;AACD,MAAIG,aAAa,GAAGC,MAAM,CAACC,iBAA3B;;AACA,MAAIN,MAAM,IAAI,CAAd,EAAiB;AACbI,IAAAA,aAAa,GAAGH,SAAS,CAAC,CAAD,CAAzB;AACH;;AACD,SAAO,SAASM,0BAAT,CAAoCC,MAApC,EAA4C;AAC/C,WAAOA,MAAM,CAACC,IAAP,CAAY,IAAIC,kBAAJ,CAAuBX,cAAvB,EAAuCI,sBAAvC,EAA+DC,aAA/D,EAA8EF,SAA9E,CAAZ,CAAP;AACH,GAFD;AAGH;;IACKQ,kB;AACF,8BAAYX,cAAZ,EAA4BI,sBAA5B,EAAoDC,aAApD,EAAmEF,SAAnE,EAA8E;AAAA;;AAC1E,SAAKH,cAAL,GAAsBA,cAAtB;AACA,SAAKI,sBAAL,GAA8BA,sBAA9B;AACA,SAAKC,aAAL,GAAqBA,aAArB;AACA,SAAKF,SAAL,GAAiBA,SAAjB;AACH;;;;WACD,cAAKS,UAAL,EAAiBH,MAAjB,EAAyB;AACrB,aAAOA,MAAM,CAACI,SAAP,CAAiB,IAAIC,oBAAJ,CAAyBF,UAAzB,EAAqC,KAAKZ,cAA1C,EAA0D,KAAKI,sBAA/D,EAAuF,KAAKC,aAA5F,EAA2G,KAAKF,SAAhH,CAAjB,CAAP;AACH;;;;;;IAECY,O,6BACF,mBAAc;AAAA;;AACV,OAAKC,MAAL,GAAc,EAAd;AACH,C;;IAECF,oB;;;;;AACF,gCAAYG,WAAZ,EAAyBjB,cAAzB,EAAyCI,sBAAzC,EAAiEC,aAAjE,EAAgFF,SAAhF,EAA2F;AAAA;;AAAA;;AACvF,8BAAMc,WAAN;AACA,UAAKjB,cAAL,GAAsBA,cAAtB;AACA,UAAKI,sBAAL,GAA8BA,sBAA9B;AACA,UAAKC,aAAL,GAAqBA,aAArB;AACA,UAAKF,SAAL,GAAiBA,SAAjB;AACA,UAAKe,QAAL,GAAgB,EAAhB;;AACA,QAAMC,OAAO,GAAG,MAAKC,WAAL,EAAhB;;AACA,UAAKC,YAAL,GAAoBjB,sBAAsB,IAAI,IAA1B,IAAkCA,sBAAsB,GAAG,CAA/E;;AACA,QAAI,MAAKiB,YAAT,EAAuB;AACnB,UAAMC,iBAAiB,GAAG;AAAEV,QAAAA,UAAU,+BAAZ;AAAoBO,QAAAA,OAAO,EAAPA,OAApB;AAA6BnB,QAAAA,cAAc,EAAdA;AAA7B,OAA1B;;AACA,YAAKuB,GAAL,CAASJ,OAAO,CAACK,WAAR,GAAsBrB,SAAS,CAACsB,QAAV,CAAmBC,0BAAnB,EAA+C1B,cAA/C,EAA+DsB,iBAA/D,CAA/B;AACH,KAHD,MAIK;AACD,UAAMK,UAAU,GAAG;AAAEf,QAAAA,UAAU,+BAAZ;AAAoBO,QAAAA,OAAO,EAAPA;AAApB,OAAnB;AACA,UAAMS,aAAa,GAAG;AAAE5B,QAAAA,cAAc,EAAdA,cAAF;AAAkBI,QAAAA,sBAAsB,EAAtBA,sBAAlB;AAA0CQ,QAAAA,UAAU,+BAApD;AAA4DT,QAAAA,SAAS,EAATA;AAA5D,OAAtB;;AACA,YAAKoB,GAAL,CAASJ,OAAO,CAACK,WAAR,GAAsBrB,SAAS,CAACsB,QAAV,CAAmBI,mBAAnB,EAAwC7B,cAAxC,EAAwD2B,UAAxD,CAA/B;;AACA,YAAKJ,GAAL,CAASpB,SAAS,CAACsB,QAAV,CAAmBK,sBAAnB,EAA2C1B,sBAA3C,EAAmEwB,aAAnE,CAAT;AACH;;AAlBsF;AAmB1F;;;;WACD,eAAMG,KAAN,EAAa;AACT,UAAMb,QAAQ,GAAG,KAAKA,QAAtB;AACA,UAAMc,GAAG,GAAGd,QAAQ,CAACjB,MAArB;AACA,UAAIgC,mBAAJ;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,GAApB,EAAyBE,CAAC,EAA1B,EAA8B;AAC1B,YAAMf,OAAO,GAAGD,QAAQ,CAACgB,CAAD,CAAxB;AACA,YAAMlB,MAAM,GAAGG,OAAO,CAACH,MAAvB;AACAA,QAAAA,MAAM,CAACmB,IAAP,CAAYJ,KAAZ;;AACA,YAAIf,MAAM,CAACf,MAAP,IAAiB,KAAKI,aAA1B,EAAyC;AACrC4B,UAAAA,mBAAmB,GAAGd,OAAtB;AACH;AACJ;;AACD,UAAIc,mBAAJ,EAAyB;AACrB,aAAKG,YAAL,CAAkBH,mBAAlB;AACH;AACJ;;;WACD,gBAAOI,GAAP,EAAY;AACR,WAAKnB,QAAL,CAAcjB,MAAd,GAAuB,CAAvB;;AACA,uFAAaoC,GAAb;AACH;;;WACD,qBAAY;AACR,UAAQnB,QAAR,GAAkC,IAAlC,CAAQA,QAAR;AAAA,UAAkBD,WAAlB,GAAkC,IAAlC,CAAkBA,WAAlB;;AACA,aAAOC,QAAQ,CAACjB,MAAT,GAAkB,CAAzB,EAA4B;AACxB,YAAMkB,OAAO,GAAGD,QAAQ,CAACoB,KAAT,EAAhB;AACArB,QAAAA,WAAW,CAACsB,IAAZ,CAAiBpB,OAAO,CAACH,MAAzB;AACH;;AACD;AACH;;;WACD,wBAAe;AACX,WAAKE,QAAL,GAAgB,IAAhB;AACH;;;WACD,sBAAaC,OAAb,EAAsB;AAClB,WAAKqB,YAAL,CAAkBrB,OAAlB;AACA,UAAMK,WAAW,GAAGL,OAAO,CAACK,WAA5B;AACAA,MAAAA,WAAW,CAACiB,WAAZ;AACA,WAAKC,MAAL,CAAYlB,WAAZ;;AACA,UAAI,CAAC,KAAKmB,MAAN,IAAgB,KAAKtB,YAAzB,EAAuC;AACnCF,QAAAA,OAAO,GAAG,KAAKC,WAAL,EAAV;AACA,YAAMpB,cAAc,GAAG,KAAKA,cAA5B;AACA,YAAMsB,iBAAiB,GAAG;AAAEV,UAAAA,UAAU,EAAE,IAAd;AAAoBO,UAAAA,OAAO,EAAPA,OAApB;AAA6BnB,UAAAA,cAAc,EAAdA;AAA7B,SAA1B;AACA,aAAKuB,GAAL,CAASJ,OAAO,CAACK,WAAR,GAAsB,KAAKrB,SAAL,CAAesB,QAAf,CAAwBC,0BAAxB,EAAoD1B,cAApD,EAAoEsB,iBAApE,CAA/B;AACH;AACJ;;;WACD,uBAAc;AACV,UAAMH,OAAO,GAAG,IAAIJ,OAAJ,EAAhB;AACA,WAAKG,QAAL,CAAciB,IAAd,CAAmBhB,OAAnB;AACA,aAAOA,OAAP;AACH;;;WACD,sBAAaA,OAAb,EAAsB;AAClB,WAAKF,WAAL,CAAiBsB,IAAjB,CAAsBpB,OAAO,CAACH,MAA9B;AACA,UAAME,QAAQ,GAAG,KAAKA,QAAtB;AACA,UAAM0B,WAAW,GAAG1B,QAAQ,GAAGA,QAAQ,CAAC2B,OAAT,CAAiB1B,OAAjB,CAAH,GAA+B,CAAC,CAA5D;;AACA,UAAIyB,WAAW,IAAI,CAAnB,EAAsB;AAClB1B,QAAAA,QAAQ,CAAC4B,MAAT,CAAgB5B,QAAQ,CAAC2B,OAAT,CAAiB1B,OAAjB,CAAhB,EAA2C,CAA3C;AACH;AACJ;;;;EA5E8BtB,U;;AA8EnC,SAAS6B,0BAAT,CAAoCqB,KAApC,EAA2C;AACvC,MAAMnC,UAAU,GAAGmC,KAAK,CAACnC,UAAzB;AACA,MAAMoC,WAAW,GAAGD,KAAK,CAAC5B,OAA1B;;AACA,MAAI6B,WAAJ,EAAiB;AACbpC,IAAAA,UAAU,CAAC4B,YAAX,CAAwBQ,WAAxB;AACH;;AACD,MAAI,CAACpC,UAAU,CAAC+B,MAAhB,EAAwB;AACpBI,IAAAA,KAAK,CAAC5B,OAAN,GAAgBP,UAAU,CAACQ,WAAX,EAAhB;AACA2B,IAAAA,KAAK,CAAC5B,OAAN,CAAcK,WAAd,GAA4B,KAAKC,QAAL,CAAcsB,KAAd,EAAqBA,KAAK,CAAC/C,cAA3B,CAA5B;AACH;AACJ;;AACD,SAAS8B,sBAAT,CAAgCiB,KAAhC,EAAuC;AACnC,MAAQ3C,sBAAR,GAA0E2C,KAA1E,CAAQ3C,sBAAR;AAAA,MAAgCJ,cAAhC,GAA0E+C,KAA1E,CAAgC/C,cAAhC;AAAA,MAAgDY,UAAhD,GAA0EmC,KAA1E,CAAgDnC,UAAhD;AAAA,MAA4DT,SAA5D,GAA0E4C,KAA1E,CAA4D5C,SAA5D;AACA,MAAMgB,OAAO,GAAGP,UAAU,CAACQ,WAAX,EAAhB;AACA,MAAM6B,MAAM,GAAG,IAAf;;AACA,MAAI,CAACrC,UAAU,CAAC+B,MAAhB,EAAwB;AACpB/B,IAAAA,UAAU,CAACW,GAAX,CAAeJ,OAAO,CAACK,WAAR,GAAsBrB,SAAS,CAACsB,QAAV,CAAmBI,mBAAnB,EAAwC7B,cAAxC,EAAwD;AAAEY,MAAAA,UAAU,EAAVA,UAAF;AAAcO,MAAAA,OAAO,EAAPA;AAAd,KAAxD,CAArC;AACA8B,IAAAA,MAAM,CAACxB,QAAP,CAAgBsB,KAAhB,EAAuB3C,sBAAvB;AACH;AACJ;;AACD,SAASyB,mBAAT,CAA6BqB,GAA7B,EAAkC;AAC9B,MAAQtC,UAAR,GAAgCsC,GAAhC,CAAQtC,UAAR;AAAA,MAAoBO,OAApB,GAAgC+B,GAAhC,CAAoB/B,OAApB;AACAP,EAAAA,UAAU,CAAC4B,YAAX,CAAwBrB,OAAxB;AACH","sourcesContent":["import { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isScheduler } from '../util/isScheduler';\nexport function bufferTime(bufferTimeSpan) {\n    let length = arguments.length;\n    let scheduler = async;\n    if (isScheduler(arguments[arguments.length - 1])) {\n        scheduler = arguments[arguments.length - 1];\n        length--;\n    }\n    let bufferCreationInterval = null;\n    if (length >= 2) {\n        bufferCreationInterval = arguments[1];\n    }\n    let maxBufferSize = Number.POSITIVE_INFINITY;\n    if (length >= 3) {\n        maxBufferSize = arguments[2];\n    }\n    return function bufferTimeOperatorFunction(source) {\n        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n    };\n}\nclass BufferTimeOperator {\n    constructor(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n    }\n}\nclass Context {\n    constructor() {\n        this.buffer = [];\n    }\n}\nclass BufferTimeSubscriber extends Subscriber {\n    constructor(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        super(destination);\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n        this.contexts = [];\n        const context = this.openContext();\n        this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n        if (this.timespanOnly) {\n            const timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n        else {\n            const closeState = { subscriber: this, context };\n            const creationState = { bufferTimeSpan, bufferCreationInterval, subscriber: this, scheduler };\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n        }\n    }\n    _next(value) {\n        const contexts = this.contexts;\n        const len = contexts.length;\n        let filledBufferContext;\n        for (let i = 0; i < len; i++) {\n            const context = contexts[i];\n            const buffer = context.buffer;\n            buffer.push(value);\n            if (buffer.length == this.maxBufferSize) {\n                filledBufferContext = context;\n            }\n        }\n        if (filledBufferContext) {\n            this.onBufferFull(filledBufferContext);\n        }\n    }\n    _error(err) {\n        this.contexts.length = 0;\n        super._error(err);\n    }\n    _complete() {\n        const { contexts, destination } = this;\n        while (contexts.length > 0) {\n            const context = contexts.shift();\n            destination.next(context.buffer);\n        }\n        super._complete();\n    }\n    _unsubscribe() {\n        this.contexts = null;\n    }\n    onBufferFull(context) {\n        this.closeContext(context);\n        const closeAction = context.closeAction;\n        closeAction.unsubscribe();\n        this.remove(closeAction);\n        if (!this.closed && this.timespanOnly) {\n            context = this.openContext();\n            const bufferTimeSpan = this.bufferTimeSpan;\n            const timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };\n            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n    }\n    openContext() {\n        const context = new Context();\n        this.contexts.push(context);\n        return context;\n    }\n    closeContext(context) {\n        this.destination.next(context.buffer);\n        const contexts = this.contexts;\n        const spliceIndex = contexts ? contexts.indexOf(context) : -1;\n        if (spliceIndex >= 0) {\n            contexts.splice(contexts.indexOf(context), 1);\n        }\n    }\n}\nfunction dispatchBufferTimeSpanOnly(state) {\n    const subscriber = state.subscriber;\n    const prevContext = state.context;\n    if (prevContext) {\n        subscriber.closeContext(prevContext);\n    }\n    if (!subscriber.closed) {\n        state.context = subscriber.openContext();\n        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n    }\n}\nfunction dispatchBufferCreation(state) {\n    const { bufferCreationInterval, bufferTimeSpan, subscriber, scheduler } = state;\n    const context = subscriber.openContext();\n    const action = this;\n    if (!subscriber.closed) {\n        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber, context }));\n        action.schedule(state, bufferCreationInterval);\n    }\n}\nfunction dispatchBufferClose(arg) {\n    const { subscriber, context } = arg;\n    subscriber.closeContext(context);\n}\n"]},"metadata":{},"sourceType":"module"}